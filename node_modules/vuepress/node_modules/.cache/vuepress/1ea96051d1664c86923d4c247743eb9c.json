{"remainingRequest":"/Users/kenquietwei/Desktop/documents/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/kenquietwei/Desktop/documents/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/kenquietwei/Desktop/documents/docs/QT/ES6/20-Class的继承.md?vue&type=template&id=b77c5872&","dependencies":[{"path":"/Users/kenquietwei/Desktop/documents/docs/QT/ES6/20-Class的继承.md","mtime":1558663500588},{"path":"/Users/kenquietwei/Desktop/documents/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/kenquietwei/Desktop/documents/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/kenquietwei/Desktop/documents/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/kenquietwei/Desktop/documents/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/kenquietwei/Desktop/documents/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"class-的继承\"><a class=\"header-anchor\" href=\"#class-的继承\" aria-hidden=\"true\">#</a> Class 的继承</h1>\n<h2 id=\"简介\"><a class=\"header-anchor\" href=\"#简介\" aria-hidden=\"true\">#</a> 简介</h2>\n<ol>\n<li>Class 可以通过 extends 关键字实现继承</li>\n<li>子类必须在constructor 方法调用 super 方法，否则会报错，因为子类没有自己的 this 对象，而是继承父类的 this 对象</li>\n<li>ES6 的继承机制：先创造父类的实例对象this(所以必须先调用super方法)，然后在用子类的构造函数修改this</li>\n<li>在子类的构造函数中，只有调用了super之后才可以使用this关键字，否则会报错。<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 基础代码骨架</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">point</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ColorPoint</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">point</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> color<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br></div><!--beforeend--></div><!--afterend--></li>\n</ol>\n<h2 id=\"super-关键字\"><a class=\"header-anchor\" href=\"#super-关键字\" aria-hidden=\"true\">#</a> super 关键字</h2>\n<ol>\n<li>ES6 要求，子类的构造函数必须执行一次super函数，否者 JavaScript引擎会报错。</li>\n<li>super() 内部的this 指向的是子函数，而非父函数</li>\n<li>super() 作为函数时，只能在子类构造函数中使用，其他地方使用会报错。</li>\n<li>super 作为对象使用时，<strong>在普通方法中指向的是父类的原型对象。在静态方法中指向父类</strong>。所以super.p()相当于A.prototype.p()<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token comment\">// 在普通方法中</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// 构造函数定义方法都是在原型上</span>\n  <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token number\">2</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//2</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br><span class=\"line-number\">13</span><br><span class=\"line-number\">14</span><br></div><!--beforeend--></div><!--afterend--></li>\n</ol>\n<div class=\"tip custom-block\"><p class=\"custom-block-title\">TIP</p>\n<p>由于 super 指向父类的原型对象，所以定义在父类实例上的方法或者属性是无法通过 super 进行调用的。</p>\n</div>\n<h2 id=\"类的prototype属性和-proto-属性\"><a class=\"header-anchor\" href=\"#类的prototype属性和-proto-属性\" aria-hidden=\"true\">#</a> 类的prototype属性和__proto__属性</h2>\n<ol>\n<li>Class 作为构造函数的语法糖，同时有 prototype 属性和 <strong>proto</strong> 属性，因此同时存在两条继承链\n<ul>\n<li>子类的 <strong>proto</strong> 属性表示构造函数的继承，总是指向父类</li>\n<li>子类的 prototype 属性的 <strong>proto</strong> 属性表示方法的继承，总是指向父类的 prototype 属性</li>\n</ul>\n<!--beforebegin--><div class=\"language-js line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-js\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span>\n  \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">{</span>\n  \n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">B</span><span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token comment\">//true</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br></div><!--beforeend--></div><!--afterend--></li>\n<li>可以这么说：作为对象，子类(B)的原型( <strong>proto</strong> 属性)是父类(A)；作为构造函数，子类(B)的原型（prototype 属性）是父类的实例。</li>\n</ol>\n<div class=\"tip custom-block\"><p class=\"custom-block-title\">TIP</p>\n<p>对象：子的原型是父，子的原型的原型就是父的原型</p>\n</div>\n</div>\n",null]}