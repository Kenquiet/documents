# Module
## require 及其运行机制
1. Node 遵循 CommonJS 来规范，使用require 来进行加载模块
    ```js
    // 定义一个简单的模块
    let person = {
        talk:function() {
          console.log('I am talking...');
        },
        listen:function() {
          console.log('I am listening...');
        }
    };
    // 向外暴露接口
    module.exports = person;
    ```
2. 该模块提供了 person 接口，使用module.exports 向外暴露接口，在外部需要引用的话就需要require关键字进行引用
    ```js
    let person = require('./person.js');
    person.talk();
    ```
3. 如果只需要到这个模块的 talk 方法，可以这样引用
    ```js
    let talk = require('./person').talk;
    talk();
    ```
### 关于重复引用问题
1. 在 node 中无需关心这个问题，因为node在第一次引用时会将模块加载到缓存中，在再次引用的时候默认从缓存中加载，如果没有才会新加载该模块。
2. 面试官问题： 为什么Node.js 中，require( )加载模块是同步而非异步？
    + 首先：node 遵循CommonJS 的标准
    + 这个是出于程序员的直觉，一个作为公共依赖的模块，当然是一步加载到位。
    + 模块的个数是有限的，Node中会自动缓存已经加载的模块，再加上访问的都是本地文件，产生的IO开销几乎可以忽略。
    + node 程序运行在服务器端，应该不会频繁重启服务器的吧，那么在重启服务器的时候花多几秒时间也没什么影响的。
## 模块化与作用域
### this
1. 既然有作用域的问题，那么this又是指向什么呢？
    + 建立一个this.js 脚本
        ```js
        let a = 10;
        console.log(this.a);// undefined
        console.log(global.a); //undefined
        ```
    说明 let = a 并没有挂载到全局的 this 或者 global对象上
    + 进行继续测试
        ```js
        a=10;
        console.log(this.a);// undefined
        console.log(global.a); // 5 
        ```
    说明两者在脚本文件中并不等价！
    + 其实 this 指向的是 module.exports。
        ```js
        this.a = 10;
        console.log(module.exports);//10
        ```
### Node 中作用域的种类
1. 全局作用域(ES5)
    + 如果一个变量没有使用 var或者let 进行定义，那么他就是全局作用域的内容，可以使用global对象进行访问，即使不在同一文件也能进行访问。
2. 模块作用域
    + 在模块作用域中使用 var、let、const 定义的变量在模块作用域中，模块与模块是不能直接访问的，模块作用域中的this指向 module.exports 中
3. 函数作用域(ES5)
4. 块级作用域(ES6)
## Buffer
1. 作用是用来处理二进制数据的，通常表现十六进制的字符串。(现在已经不推荐使用Buffer了，而是使用Buffer.form)
### Buffer.from
1. 使用Buffer.from 来初始化一个Buffer
    ```js
    let buffer= Buffer.from('hello node');
    console.log(buffer);//<Buffer 68 65 6c 6c 6f 20 6e 6f 64 65>
    ```
2. 使用toString 方法来将 Buffer 对象转换成字符串形式
    + buffer.toString([encoding],[start],[end])
        - encoding -- 目标编码格式
        - start -- 开始位置
        - end -- 结束位置
    + toString() 方法不给任何参数就是默认utf-8，并转换整个Buffer 对象
    ```js
    let buffer= Buffer.from('hello node');
    console.log(buffer.toString('utf-8',0,10));//hello node
    ```
## file System
1. file System 是Node中使用最频繁的模块之一，这个模块提供了读写文件的能力，比较常用的api列举
### readFile
1.readFile 用来异步读取文件中的内容
    ```js
    let http = require('http');
    let fs = require('fs');
    let server = http.createServer();
    server.on('request',function(req,res) {
        fs.readFile('./1.md',function(err,data) {
          if(err) throw err;
          res.end(data);
        })
    })
    ```
    其实我们可以使用toString 方法来进行转换为字符串，但是res.end 支持字符串
### writeFile
1. writeFile 可以用来进行文件写入
    ```
    fs.writeFile(file,data[,options],callback());
    // 参数1：文件路径/文件名
    // 参数2：文件内容(options是字符串，则指定编码)
    // 参数3：回调函数
    ```
## HTTP服务
1. HTTP 主要提供了一系列用于网络传输的API
### 创建HTTP 服务器
1. 通常使用 createServer 方法创建HTTP服务器，该方法返回一个http.server 类实例，
    ```js
    let http = require('http');
    let server = http.createServer();
    server.on('request',function(req,res) {
      
    });
    
    server.listen('3000',function() {
      console.log('服务器启动成功了~~')
    })
    ```
### 处理HTTP请求
1. 档处理HTTP请求时，最先做的事是获取请求的URL、method等信息
2. method 的值一般是 get、post、put、delete、update 5个关键字之一
    ```js
    let http = require('http');
    let server = http.createServer();
    server.on('request',function (req,res) {
       let method = req.method;
       let url = req.url;
       res.end(console.log(method));//GET
       res.end(console.log(url));// /或者 favicon.ico
    });
    server.listen('3000',function () {
        console.log("服务器启动成功了~~")
    });
    ```
3. http header 在Chrome控制台中可以查看，形式就不说了，复制上面的代码运行之后去NotWork中查看

4.  Node 使用 stream 来处理HTTP请求体，stream 注册了 data和 end 两个事件
