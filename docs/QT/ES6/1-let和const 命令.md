# let 和 const 命令

## let 命令
### 基本用法
ES6 新增了 let 命令，用于声明变量。用法和 var 类似，但是 let 声明只在代码块内有效，也就是let 有会计作用域，这就很好的解决了 for 循环计数器的问题
```js{6}
let a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function () {
       console.log(i);// 这里不再是 10， 而是输出6
    };
}
a[6](); // 6
``` 
上面的代码中，使用了 let 之后 for循环就拥有了块级作用域，每一次输出i都会返回一个i，而且每一个 i 只在当次循环有效，所以每一次循环的 i 其实都是一个新的变量  
### 不存在变量提升
var 命令会发生"变量提升" 现象，即变量在声明之前使用，值为 undefined。为了更加的符合逻辑，**let 命令改变了语法，必须在声明之后才可以使用，否则会报错**
```js
// var 情况
console.log(a); // 输出值为 undefined
var a = 2;

// let 情况
console.log(b); // 报错
let b = 3;
```
### 暂时性死区
只要在块级作用域内存在 let 或者 const 命令，那么这个区域的变量不再受外部影响，
总之在代码块内，使用了let 命令声明变量之前，该变量都是不可以使用的，语法上这称为"暂时性死区"。
```js
var a = 123;

if (true) {
    a = 'abc';
    console.log(a); // 报错
    let a;
} 
``` 
### 不允许重复声明
let 不允许在同一个作用域内重复声明同一个变量。
```js
// 重复声明报错
 let c = function () {
    let a = 10;
    var a = 1;
}
```
### 块级作用域
ES5 只有全局作用域和函数作用域，没有块级作用域，这样有些地方很麻烦。
例如-数据泄露：
```js
// 使用 var 情况
var  s = 'hello';
for (var i=0; i<s.length; i++ ){
    console.log(s[i]);
}
console.log(i);//5  这里我们并没有定义i，但是for循环中将 i=5 最终泄露出来了。
```
let 实际上为 JavaScript 新增了块级作用域
```js
// 使用 let 情况
 for (let i=0; i<3; i++){
     let a = i+1;
     console.log(a);
 }
 console.log(i);// 没有定义 i 所以报错 
```
### 块级作用域与函数声明
1. ES5 不允许在块级作用域中声明函数。
2. ES6 
    + 允许块级作用域内声明函数；
    + 函数声明雷类似于 var，会提升到全局作用域或者函数作用域头部
    + 同时，函数声明还会提升到所在的会计作用域的头部
::: tip
考虑到环境导致的行为差异过大，应该避免在块级作用域内声明函数，如有需要，则该写成函数表达式的形式，而不是函数声明语句。
:::
```js
// 函数声明语句
{
    let a = 'hello';
    function f() {
        return a;
    }
}
// 函数表达式
{
    let b = 'secret';
    let f2 = function（）{
        return b;
    }
}
```
## const 命令
### 基本用法
const 声明一个只读常量，一旦声明，值就不能改变  
const 一旦声明，就必须初始化，不能留到后面赋值  
const 的作用域与 let 命令相同，只在声明所在的块级作用域有效  
const 命令声明的畅想也不会提升，同样存在暂时性死区，也只能在声明后使用，不可重复声明
### 本质
const 从本质上说其实就是一个指针，声明的变量指向那个内存地址，值就保存在这个地址中，而const只能保证这个指针是固定的，至于指向的数据结构是不是可变，const 无法控制。
